// Vercel Serverless Function — Transaction Monitoring & Fraud Detection (36 rules, 16 categories)
// POST /api/screening/transaction-monitoring

class TransactionMonitoringService {
  constructor() {
    this.rules = this._initRules();
    this.highRiskCountries = new Set(['AF','BY','MM','CF','CD','CU','GQ','ER','IR','IQ','LB','LY','ML','NI','KP','SO','SS','SD','SY','VE','YE','ZW','RU']);
    this.taxHavens = new Set(['VG','KY','BM','PA','SC','BS','JE','GG','IM','LI','MC','GI','AI','TC','WS','VU','MH','BZ','AG','DM','KN','LC','VC','CK','NR','NU','SM']);
    this.highRiskMCCs = new Set(['6051','6211','6012','7995','5933','5944','5094','7273','4829','6050','6010','6540','7801','7802','7800']);
  }

  async analyzeTransactions(params) {
    const { transactions, entityProfile, options = {} } = params;
    if (!transactions || transactions.length === 0) return { alerts: [], riskScore: 0, summary: 'No transactions to analyze' };
    const normalized = transactions.map(tx => this._normalize(tx));
    const profile = entityProfile || this._buildProfile(normalized);
    const alerts = [];
    for (const rule of this.rules) {
      if (options.categories && !options.categories.includes(rule.category)) continue;
      try { alerts.push(...rule.detect(normalized, profile)); } catch {}
    }
    alerts.sort((a, b) => b.score - a.score);
    const compositeRisk = this._computeCompositeRiskScore(alerts, profile);
    return { entityProfile: profile, transactionCount: normalized.length, alerts, riskAssessment: { score: compositeRisk.compositeScore, level: compositeRisk.level, alertCount: alerts.length, priority: compositeRisk.priority, sla: compositeRisk.sla, sarRequired: compositeRisk.sarRequired, recommendedActions: compositeRisk.recommendedActions }, compositeScoring: compositeRisk, categorySummary: this._categorySummary(alerts), screenedAt: new Date().toISOString() };
  }

  _normalize(tx) {
    return { id: tx.id || tx.transactionId || Math.random().toString(36).slice(2), date: new Date(tx.date || tx.timestamp || tx.transactionDate), amount: parseFloat(tx.amount || 0), currency: (tx.currency || 'USD').toUpperCase(), type: (tx.type || tx.transactionType || 'UNKNOWN').toUpperCase(), direction: (tx.direction || (tx.amount > 0 ? 'CREDIT' : 'DEBIT')).toUpperCase(), counterparty: tx.counterparty || tx.counterpartyName || tx.beneficiary || '', counterpartyCountry: (tx.counterpartyCountry || tx.country || '').toUpperCase(), counterpartyAccount: tx.counterpartyAccount || tx.beneficiaryAccount || '', channel: (tx.channel || 'UNKNOWN').toUpperCase(), mcc: tx.mcc || tx.merchantCategoryCode || '', description: tx.description || tx.narrative || '', reference: tx.reference || '', cryptoAddress: tx.cryptoAddress || tx.walletAddress || '', blockchain: tx.blockchain || '' };
  }

  _buildProfile(txs) {
    if (!txs.length) return { avgAmount: 0, totalVolume: 0, txCount: 0 };
    const amounts = txs.map(t => Math.abs(t.amount)); const total = amounts.reduce((s, a) => s + a, 0);
    const countries = new Set(txs.map(t => t.counterpartyCountry).filter(Boolean));
    const dates = txs.map(t => t.date).sort((a, b) => a - b); const daySpan = Math.max(1, (dates[dates.length - 1] - dates[0]) / 86400000);
    return { avgAmount: total / amounts.length, medianAmount: amounts.sort((a, b) => a - b)[Math.floor(amounts.length / 2)], maxAmount: Math.max(...amounts), totalVolume: total, txCount: txs.length, txPerDay: txs.length / daySpan, uniqueCounterparties: new Set(txs.map(t => t.counterparty).filter(Boolean)).size, uniqueCountries: countries.size, countries: [...countries], dateRange: { from: dates[0]?.toISOString(), to: dates[dates.length - 1]?.toISOString(), days: daySpan } };
  }

  _categorySummary(alerts) { const cats = {}; for (const a of alerts) { if (!cats[a.category]) cats[a.category] = { count: 0, maxScore: 0 }; cats[a.category].count++; cats[a.category].maxScore = Math.max(cats[a.category].maxScore, a.score); } return cats; }

  _computeCompositeRiskScore(alerts, profile = {}) {
    const caps = { STRUCTURING: 50, VELOCITY: 45, GEOGRAPHIC: 40, COUNTERPARTY: 50, BEHAVIORAL: 35, CRYPTO: 55, TBML: 50, REAL_ESTATE: 45, GAMBLING: 35, INTEGRATION: 40, MSB_HAWALA: 45, SECURITIES: 40, HUMAN_TRAFFICKING: 55, CASH_BUSINESS: 35, SANCTIONS_EVASION: 60, CORRUPTION: 50, NETWORK: 50, FRAUD: 55 };
    const weights = { SANCTIONS_EVASION: 1.5, HUMAN_TRAFFICKING: 1.4, CORRUPTION: 1.3, CRYPTO: 1.2, STRUCTURING: 1.1, COUNTERPARTY: 1.1, TBML: 1.2, NETWORK: 1.2, FRAUD: 1.3 };
    const catScores = {};
    for (const a of alerts) catScores[a.category] = Math.min((catScores[a.category] || 0) + a.score, caps[a.category] || 40);
    let wSum = 0, wTot = 0;
    for (const [cat, score] of Object.entries(catScores)) { const w = weights[cat] || 1.0; wSum += score * w; wTot += w; }
    const raw = wTot > 0 ? wSum / wTot : 0;
    const cc = alerts.filter(a => a.severity === 'CRITICAL').length;
    const hc = alerts.filter(a => a.severity === 'HIGH').length;
    let sm = cc >= 3 ? 1.4 : cc >= 1 ? 1.2 : hc >= 5 ? 1.15 : 1.0;
    const ac = Object.keys(catScores).length;
    const cb = ac >= 5 ? 15 : ac >= 3 ? 8 : ac >= 2 ? 3 : 0;
    const fs = Math.min(100, Math.round(raw * sm + cb));
    const level = fs >= 80 ? 'CRITICAL' : fs >= 60 ? 'HIGH' : fs >= 30 ? 'MEDIUM' : 'LOW';
    let priority, sla;
    if (fs >= 80) { priority = 'P1'; sla = '4 hours'; } else if (fs >= 60) { priority = 'P2'; sla = '24 hours'; } else if (fs >= 30) { priority = 'P3'; sla = '72 hours'; } else { priority = 'P4'; sla = '5 business days'; }
    const actions = [];
    if (fs >= 80) actions.push('IMMEDIATE_ESCALATION', 'SAR_FILING', 'ACCOUNT_FREEZE_REVIEW');
    else if (fs >= 60) actions.push('SENIOR_REVIEW', 'SAR_CONSIDERATION', 'ENHANCED_MONITORING');
    else if (fs >= 30) actions.push('ANALYST_REVIEW', 'ENHANCED_DUE_DILIGENCE');
    if (catScores.SANCTIONS_EVASION > 0) actions.push('OFAC_COMPLIANCE_REVIEW');
    if (catScores.HUMAN_TRAFFICKING > 0) actions.push('LAW_ENFORCEMENT_REFERRAL');
    return { compositeScore: fs, level, priority, sla, categoryScores: catScores, activeCategoryCount: ac, severityMultiplier: sm, correlationBonus: cb, recommendedActions: [...new Set(actions)], sarRequired: fs >= 60 || ac >= 4 };
  }

  _initRules() {
    return [
      // STR-001: Just-below threshold
      { id: 'STR-001', category: 'STRUCTURING', detect: (txs) => { const jb = txs.filter(t => t.amount >= 8000 && t.amount < 10000); if (jb.length < 3) return []; const sorted = jb.sort((a, b) => a.date - b.date); for (let i = 0; i <= sorted.length - 3; i++) { const w = sorted.slice(i, i + 3); const span = (w[2].date - w[0].date) / 86400000; if (span <= 30) return [{ ruleId: 'STR-001', category: 'STRUCTURING', severity: 'HIGH', score: 35, message: `${w.length} transactions just below $10,000 threshold within ${Math.ceil(span)} days`, transactions: w.map(t => t.id), details: { amounts: w.map(t => t.amount) } }]; } return []; } },
      // STR-002: Round amounts
      { id: 'STR-002', category: 'STRUCTURING', detect: (txs) => { const r = txs.filter(t => t.amount >= 1000 && t.amount % 1000 === 0); return (r.length >= 5 && r.length / txs.length > 0.4) ? [{ ruleId: 'STR-002', category: 'STRUCTURING', severity: 'MEDIUM', score: 20, message: `${r.length}/${txs.length} transactions are round amounts`, transactions: r.slice(0, 10).map(t => t.id) }] : []; } },
      // STR-003: Split deposits
      { id: 'STR-003', category: 'STRUCTURING', detect: (txs) => { const alerts = []; const byDate = {}; for (const t of txs.filter(t => t.direction === 'CREDIT')) { const k = t.date.toISOString().slice(0, 10); (byDate[k] = byDate[k] || []).push(t); } for (const [d, g] of Object.entries(byDate)) { if (g.length >= 3) { const tot = g.reduce((s, t) => s + t.amount, 0); if (tot >= 10000 && g.every(t => t.amount < 10000)) alerts.push({ ruleId: 'STR-003', category: 'STRUCTURING', severity: 'HIGH', score: 40, message: `${g.length} deposits on ${d} totaling $${tot.toFixed(2)} — each under $10K`, transactions: g.map(t => t.id) }); } } return alerts; } },
      // STR-004: Incremental amounts
      { id: 'STR-004', category: 'STRUCTURING', detect: (txs) => { const cash = txs.filter(t => ['CASH','DEPOSIT'].includes(t.type)).sort((a, b) => a.date - b.date); for (let i = 0; i <= cash.length - 4; i++) { const w = cash.slice(i, i + 4); const d = []; for (let j = 1; j < w.length; j++) d.push(w[j].amount - w[j-1].amount); if (d.every(x => x > 0 && x < 500) || d.every(x => x < 0 && x > -500)) return [{ ruleId: 'STR-004', category: 'STRUCTURING', severity: 'MEDIUM', score: 25, message: `Incrementally ${d[0] > 0 ? 'increasing' : 'decreasing'} amounts across ${w.length} transactions`, transactions: w.map(t => t.id) }]; } return []; } },
      // VEL-001: Volume spike
      { id: 'VEL-001', category: 'VELOCITY', detect: (txs) => { const byWeek = {}; for (const t of txs) { const w = Math.floor(t.date.getTime() / 604800000); (byWeek[w] = byWeek[w] || { vol: 0, txs: [] }).vol += Math.abs(t.amount); byWeek[w].txs.push(t.id); } const weeks = Object.values(byWeek); if (weeks.length < 3) return []; const avg = weeks.reduce((s, w) => s + w.vol, 0) / weeks.length; for (const w of weeks) { if (w.vol > avg * 3 && w.vol > 50000) return [{ ruleId: 'VEL-001', category: 'VELOCITY', severity: 'HIGH', score: 30, message: `Weekly volume $${w.vol.toFixed(0)} is ${(w.vol/avg).toFixed(1)}x average`, transactions: w.txs.slice(0, 10) }]; } return []; } },
      // VEL-002: Rapid-fire
      { id: 'VEL-002', category: 'VELOCITY', detect: (txs) => { const s = [...txs].sort((a, b) => a.date - b.date); for (let i = 0; i <= s.length - 5; i++) { const span = (s[i+4].date - s[i].date) / 3600000; if (span <= 1) return [{ ruleId: 'VEL-002', category: 'VELOCITY', severity: 'HIGH', score: 30, message: `5 transactions within ${span.toFixed(1)} hours`, transactions: s.slice(i, i+5).map(t => t.id) }]; } return []; } },
      // VEL-003: Excessive daily count
      { id: 'VEL-003', category: 'VELOCITY', detect: (txs) => { const byDay = {}; for (const t of txs) { const d = t.date.toISOString().slice(0, 10); (byDay[d] = byDay[d] || []).push(t); } for (const [d, g] of Object.entries(byDay)) { if (g.length >= 15) return [{ ruleId: 'VEL-003', category: 'VELOCITY', severity: 'MEDIUM', score: 20, message: `${g.length} transactions on ${d}`, transactions: g.slice(0, 10).map(t => t.id) }]; } return []; } },
      // VEL-004: Pass-through
      { id: 'VEL-004', category: 'VELOCITY', detect: (txs) => { const s = [...txs].sort((a, b) => a.date - b.date); for (let i = 0; i < s.length - 1; i++) { if (s[i].direction !== 'CREDIT') continue; for (let j = i + 1; j < s.length; j++) { if (s[j].direction !== 'DEBIT') continue; const h = (s[j].date - s[i].date) / 3600000; if (h > 48) break; const r = s[j].amount / s[i].amount; if (r >= 0.9 && r <= 1.0 && s[i].amount > 5000) return [{ ruleId: 'VEL-004', category: 'VELOCITY', severity: 'CRITICAL', score: 45, message: `$${s[i].amount.toFixed(0)} in, $${s[j].amount.toFixed(0)} out within ${h.toFixed(1)}h — pass-through`, transactions: [s[i].id, s[j].id] }]; } } return []; } },
      // GEO-001: High-risk jurisdictions
      { id: 'GEO-001', category: 'GEOGRAPHIC', detect: (txs) => { const h = txs.filter(t => this.highRiskCountries.has(t.counterpartyCountry)); if (!h.length) return []; return [{ ruleId: 'GEO-001', category: 'GEOGRAPHIC', severity: 'HIGH', score: 35, message: `${h.length} transaction(s) with high-risk jurisdictions: ${[...new Set(h.map(t => t.counterpartyCountry))].join(', ')}`, transactions: h.slice(0, 10).map(t => t.id) }]; } },
      // GEO-002: Tax havens
      { id: 'GEO-002', category: 'GEOGRAPHIC', detect: (txs) => { const h = txs.filter(t => this.taxHavens.has(t.counterpartyCountry)); return h.length >= 3 ? [{ ruleId: 'GEO-002', category: 'GEOGRAPHIC', severity: 'MEDIUM', score: 25, message: `${h.length} transaction(s) to/from tax havens`, transactions: h.slice(0, 10).map(t => t.id) }] : []; } },
      // GEO-003: Unusual spread
      { id: 'GEO-003', category: 'GEOGRAPHIC', detect: (txs) => { const c = new Set(txs.map(t => t.counterpartyCountry).filter(Boolean)); return (c.size >= 10 && txs.length < 100) ? [{ ruleId: 'GEO-003', category: 'GEOGRAPHIC', severity: 'MEDIUM', score: 20, message: `Transactions span ${c.size} countries across ${txs.length} transactions`, transactions: [] }] : []; } },
      // CTY-001: Shell company indicators
      { id: 'CTY-001', category: 'COUNTERPARTY', detect: (txs) => { const p = /\b(holdings|trading|consulting|services|international|global|ventures|capital|group|investment)\b/i; const s = txs.filter(t => p.test(t.counterparty) && this.taxHavens.has(t.counterpartyCountry)); return s.length >= 2 ? [{ ruleId: 'CTY-001', category: 'COUNTERPARTY', severity: 'HIGH', score: 30, message: `${s.length} counterparties in tax havens with generic names`, transactions: s.slice(0, 10).map(t => t.id) }] : []; } },
      // CTY-002: Concentration risk
      { id: 'CTY-002', category: 'COUNTERPARTY', detect: (txs, profile) => { const v = {}; for (const t of txs) { if (t.counterparty) v[t.counterparty] = (v[t.counterparty] || 0) + Math.abs(t.amount); } for (const [cp, vol] of Object.entries(v)) { const r = vol / (profile.totalVolume || 1); if (r > 0.6 && vol > 50000) return [{ ruleId: 'CTY-002', category: 'COUNTERPARTY', severity: 'MEDIUM', score: 20, message: `${(r*100).toFixed(0)}% of volume with single counterparty: ${cp}`, transactions: txs.filter(t => t.counterparty === cp).slice(0, 5).map(t => t.id) }]; } return []; } },
      // CTY-003: New counterparty large tx
      { id: 'CTY-003', category: 'COUNTERPARTY', detect: (txs) => { const seen = new Set(); for (const t of [...txs].sort((a, b) => a.date - b.date)) { if (t.counterparty && !seen.has(t.counterparty) && t.amount > 25000) return [{ ruleId: 'CTY-003', category: 'COUNTERPARTY', severity: 'MEDIUM', score: 20, message: `First tx with "${t.counterparty}" is $${t.amount.toFixed(0)}`, transactions: [t.id] }]; if (t.counterparty) seen.add(t.counterparty); } return []; } },
      // CTY-004: Circular transactions
      { id: 'CTY-004', category: 'COUNTERPARTY', detect: (txs) => { const pairs = {}; for (const t of txs) { if (!t.counterparty) continue; const k = `${t.direction}:${t.counterparty}`; (pairs[k] = pairs[k] || []).push(t); } for (const cp of new Set(txs.map(t => t.counterparty).filter(Boolean))) { const s = pairs[`DEBIT:${cp}`] || [], r = pairs[`CREDIT:${cp}`] || []; if (s.length >= 2 && r.length >= 2) { const st = s.reduce((x, t) => x + t.amount, 0), rt = r.reduce((x, t) => x + t.amount, 0); if (Math.min(st, rt) / Math.max(st, rt) > 0.7 && st > 10000) return [{ ruleId: 'CTY-004', category: 'COUNTERPARTY', severity: 'CRITICAL', score: 45, message: `Circular flow with "${cp}": sent $${st.toFixed(0)}, received $${rt.toFixed(0)}`, transactions: [...s, ...r].slice(0, 10).map(t => t.id) }]; } } return []; } },
      // BEH-001: Dormant reactivation
      { id: 'BEH-001', category: 'BEHAVIORAL', detect: (txs) => { const s = [...txs].sort((a, b) => a.date - b.date); for (let i = 1; i < s.length; i++) { const gap = (s[i].date - s[i-1].date) / 86400000; if (gap >= 90 && s[i].amount > 10000) return [{ ruleId: 'BEH-001', category: 'BEHAVIORAL', severity: 'HIGH', score: 30, message: `Dormant ${Math.floor(gap)} days then $${s[i].amount.toFixed(0)} transaction`, transactions: [s[i].id] }]; } return []; } },
      // BEH-002: Off-hours
      { id: 'BEH-002', category: 'BEHAVIORAL', detect: (txs) => { const o = txs.filter(t => { const h = t.date.getUTCHours(); return h < 5 || h >= 23; }); return (o.length >= 5 && o.length / txs.length > 0.3) ? [{ ruleId: 'BEH-002', category: 'BEHAVIORAL', severity: 'LOW', score: 10, message: `${o.length} off-hours transactions`, transactions: o.slice(0, 5).map(t => t.id) }] : []; } },
      // BEH-003: Channel switching
      { id: 'BEH-003', category: 'BEHAVIORAL', detect: (txs) => { const s = [...txs].sort((a, b) => a.date - b.date); let sw = 0; for (let i = 1; i < s.length; i++) if (s[i].channel !== s[i-1].channel && s[i].channel !== 'UNKNOWN' && s[i-1].channel !== 'UNKNOWN') sw++; return (sw > txs.length * 0.6 && txs.length > 5) ? [{ ruleId: 'BEH-003', category: 'BEHAVIORAL', severity: 'MEDIUM', score: 15, message: `${sw} channel switches across ${txs.length} transactions`, transactions: [] }] : []; } },
      // BEH-004: Amount outliers
      { id: 'BEH-004', category: 'BEHAVIORAL', detect: (txs) => { if (txs.length < 5) return []; const a = txs.map(t => Math.abs(t.amount)).sort((a, b) => a - b); const q1 = a[Math.floor(a.length * 0.25)], q3 = a[Math.floor(a.length * 0.75)], fence = q3 + 3 * (q3 - q1); const out = txs.filter(t => Math.abs(t.amount) > fence && Math.abs(t.amount) > 10000); return out.length ? [{ ruleId: 'BEH-004', category: 'BEHAVIORAL', severity: 'HIGH', score: 25, message: `${out.length} extreme outlier transaction(s) exceeding $${fence.toFixed(0)}`, transactions: out.slice(0, 5).map(t => t.id) }] : []; } },
      // BEH-005: High-risk MCCs
      { id: 'BEH-005', category: 'BEHAVIORAL', detect: (txs) => { const r = txs.filter(t => this.highRiskMCCs.has(t.mcc)); return r.length >= 3 ? [{ ruleId: 'BEH-005', category: 'BEHAVIORAL', severity: 'MEDIUM', score: 20, message: `${r.length} high-risk MCC transactions`, transactions: r.slice(0, 5).map(t => t.id) }] : []; } },
      // CRY-001: Crypto exchange activity
      { id: 'CRY-001', category: 'CRYPTO', detect: (txs) => { const p = /\b(coinbase|binance|kraken|bitfinex|bitstamp|gemini|ftx|huobi|okex|kucoin|bybit|crypto\.com)\b/i; const e = txs.filter(t => p.test(t.counterparty) || p.test(t.description)); return e.length >= 3 ? [{ ruleId: 'CRY-001', category: 'CRYPTO', severity: 'MEDIUM', score: 20, message: `${e.length} crypto exchange transactions`, transactions: e.slice(0, 5).map(t => t.id) }] : []; } },
      // CRY-002: Rapid crypto-fiat conversion
      { id: 'CRY-002', category: 'CRYPTO', detect: (txs) => { const p = /\b(coinbase|binance|kraken|bitfinex|bitstamp|gemini|ftx|huobi|okex|kucoin|bybit|crypto\.com)\b/i; const s = txs.filter(t => p.test(t.counterparty) || p.test(t.description)).sort((a, b) => a.date - b.date); for (let i = 0; i < s.length - 1; i++) { if (s[i].direction === 'CREDIT' && s[i+1].direction === 'DEBIT') { const h = (s[i+1].date - s[i].date) / 3600000; if (h <= 24 && s[i].amount > 5000) return [{ ruleId: 'CRY-002', category: 'CRYPTO', severity: 'HIGH', score: 30, message: `Rapid crypto-fiat conversion: $${s[i].amount.toFixed(0)} in/out within ${h.toFixed(1)}h`, transactions: [s[i].id, s[i+1].id] }]; } } return []; } },
      // CRY-003: Mixer/P2P indicators
      { id: 'CRY-003', category: 'CRYPTO', detect: (txs) => { const alerts = []; const m = txs.filter(t => /\b(tornado|mixer|tumbler|wasabi|samourai|chipmixer|blender)\b/i.test(t.counterparty) || /\b(tornado|mixer|tumbler|wasabi|samourai|chipmixer|blender)\b/i.test(t.description)); if (m.length) alerts.push({ ruleId: 'CRY-003', category: 'CRYPTO', severity: 'CRITICAL', score: 50, message: `${m.length} mixer/tumbler transaction(s)`, transactions: m.map(t => t.id) }); const p = txs.filter(t => /\b(localbitcoins|paxful|bisq|hodlhodl)\b/i.test(t.counterparty)); if (p.length >= 3) alerts.push({ ruleId: 'CRY-003', category: 'CRYPTO', severity: 'MEDIUM', score: 20, message: `${p.length} P2P platform transactions`, transactions: p.slice(0, 5).map(t => t.id) }); return alerts; } },
      // TBML-001: Over/under invoicing
      { id: 'TBML-001', category: 'TBML', detect: (txs) => { const trade = txs.filter(t => /\b(invoice|trade|import|export|shipment|cargo|freight|goods)\b/i.test(t.description)); if (trade.length < 2) return []; const byCp = {}; for (const t of trade) { if (t.counterparty) (byCp[t.counterparty] = byCp[t.counterparty] || []).push(t); } for (const [cp, g] of Object.entries(byCp)) { if (g.length < 2) continue; const a = g.map(t => t.amount).sort((a, b) => a - b); const r = a[a.length-1] / a[0]; if (r > 5 && a[a.length-1] > 10000) return [{ ruleId: 'TBML-001', category: 'TBML', severity: 'HIGH', score: 35, message: `Trade invoices to "${cp}" vary ${r.toFixed(1)}x — possible over/under invoicing`, transactions: g.slice(0, 5).map(t => t.id) }]; } return []; } },
      // TBML-002: Phantom invoicing
      { id: 'TBML-002', category: 'TBML', detect: (txs) => { const p = txs.filter(t => t.direction === 'DEBIT' && t.amount > 10000 && /\b(consulting|services|advisory|management fee|commission|licensing|royalt)\b/i.test(t.description) && this.taxHavens.has(t.counterpartyCountry)); return p.length >= 2 ? [{ ruleId: 'TBML-002', category: 'TBML', severity: 'HIGH', score: 35, message: `${p.length} vague "services" payments to tax havens totaling $${p.reduce((s,t) => s+t.amount, 0).toFixed(0)}`, transactions: p.slice(0, 5).map(t => t.id) }] : []; } },
      // RE-001: Real estate integration
      { id: 'RE-001', category: 'REAL_ESTATE', detect: (txs) => { const re = txs.filter(t => t.amount > 50000 && /\b(escrow|title|realty|real estate|property|mortgage|closing|deed)\b/i.test(t.description || t.counterparty)); if (!re.length) return []; const alerts = []; for (const t of re) { const prior = txs.filter(p => p.direction === 'CREDIT' && ['CASH','DEPOSIT'].includes(p.type) && p.amount < 10000 && p.date < t.date && (t.date - p.date) / 86400000 < 30); if (prior.length >= 3) { alerts.push({ ruleId: 'RE-001', category: 'REAL_ESTATE', severity: 'HIGH', score: 40, message: 'Real estate payment preceded by structured cash deposits', transactions: [t.id] }); break; } } return alerts; } },
      // GAM-001: Casino/gambling
      { id: 'GAM-001', category: 'GAMBLING', detect: (txs) => { const g = txs.filter(t => /\b(casino|wager|bet365|draftkings|fanduel|pokerstars|gambling|sportsbook)\b/i.test(t.counterparty) || t.mcc === '7995'); if (g.length < 3) return []; const tot = g.reduce((s,t) => s + Math.abs(t.amount), 0); const cr = g.filter(t => t.direction === 'CREDIT'); const dr = g.filter(t => t.direction === 'DEBIT'); if (cr.length && dr.length) { const crt = cr.reduce((s,t) => s+t.amount, 0); const drt = dr.reduce((s,t) => s+t.amount, 0); if (crt/drt > 0.8 && tot > 10000) return [{ ruleId: 'GAM-001', category: 'GAMBLING', severity: 'HIGH', score: 30, message: `Casino buy-in/cash-out: $${drt.toFixed(0)} in, $${crt.toFixed(0)} out — minimal loss`, transactions: g.slice(0, 10).map(t => t.id) }]; } return tot > 20000 ? [{ ruleId: 'GAM-001', category: 'GAMBLING', severity: 'MEDIUM', score: 20, message: `${g.length} gambling transactions totaling $${tot.toFixed(0)}`, transactions: g.slice(0, 5).map(t => t.id) }] : []; } },
      // INT-001: Loan-back scheme
      { id: 'INT-001', category: 'INTEGRATION', detect: (txs) => { const loans = txs.filter(t => /\b(loan|mortgage|credit|collateral|disbursement)\b/i.test(t.description)); if (loans.length < 2) return []; const sorted = [...txs].sort((a, b) => a.date - b.date); for (const t of sorted) { if (t.direction !== 'CREDIT' || t.amount < 50000) continue; const lf = loans.filter(l => l.date > t.date && (l.date - t.date) / 86400000 < 60 && l.direction === 'CREDIT'); if (lf.length) return [{ ruleId: 'INT-001', category: 'INTEGRATION', severity: 'HIGH', score: 35, message: `Large deposit ($${t.amount.toFixed(0)}) followed by loan disbursement — possible loan-back`, transactions: [t.id, ...lf.map(l => l.id)] }]; } return []; } },
      // MSB-001: Hawala/remittance
      { id: 'MSB-001', category: 'MSB_HAWALA', detect: (txs) => { const msb = txs.filter(t => /\b(remit|money gram|western union|ria|xoom|worldremit|remitly|wise|hawala)\b/i.test(t.counterparty) || ['4829','6051','6050','6540'].includes(t.mcc)); if (msb.length < 3) return []; const hrc = ['PK','AF','SO','YE','SY','IQ','LB','MM','BD','NP','KE','NG','ET']; const c = msb.filter(t => hrc.includes(t.counterpartyCountry)); return c.length >= 2 ? [{ ruleId: 'MSB-001', category: 'MSB_HAWALA', severity: 'HIGH', score: 35, message: `${c.length} remittances to high-risk corridors`, transactions: c.slice(0, 5).map(t => t.id) }] : msb.reduce((s,t) => s + Math.abs(t.amount), 0) > 20000 ? [{ ruleId: 'MSB-001', category: 'MSB_HAWALA', severity: 'MEDIUM', score: 20, message: `${msb.length} MSB/remittance transactions`, transactions: msb.slice(0, 5).map(t => t.id) }] : []; } },
      // SEC-001: Securities pass-through
      { id: 'SEC-001', category: 'SECURITIES', detect: (txs) => { const sec = txs.filter(t => /\b(brokerage|securities|stock|bond|option|futures|etf|custod)\b/i.test(t.counterparty) || t.mcc === '6211'); if (sec.length < 3) return []; const dep = sec.filter(t => t.direction === 'CREDIT').sort((a,b) => a.date - b.date); const wit = sec.filter(t => t.direction === 'DEBIT').sort((a,b) => a.date - b.date); for (const d of dep) { const qw = wit.find(w => w.date > d.date && (w.date - d.date) / 86400000 < 7 && w.amount / d.amount >= 0.85 && d.amount > 25000); if (qw) return [{ ruleId: 'SEC-001', category: 'SECURITIES', severity: 'HIGH', score: 30, message: `Brokerage deposit $${d.amount.toFixed(0)} then $${qw.amount.toFixed(0)} withdrawal in 7 days`, transactions: [d.id, qw.id] }]; } return []; } },
      // HT-001: Human trafficking
      { id: 'HT-001', category: 'HUMAN_TRAFFICKING', detect: (txs) => { const ht = txs.filter(t => /\b(massage|spa|nail salon|escort|staffing|labor|cleaning)\b/i.test(t.counterparty)); if (ht.length < 3) return []; const cash = ht.filter(t => t.direction === 'CREDIT' && ['CASH','DEPOSIT'].includes(t.type)); if (cash.length >= 5) return [{ ruleId: 'HT-001', category: 'HUMAN_TRAFFICKING', severity: 'CRITICAL', score: 45, message: `${cash.length} cash deposits from high-risk businesses — possible trafficking proceeds`, transactions: cash.slice(0, 10).map(t => t.id) }]; return []; } },
      // CIB-001: Cash-intensive business
      { id: 'CIB-001', category: 'CASH_BUSINESS', detect: (txs) => { const cash = txs.filter(t => ['CASH','DEPOSIT'].includes(t.type) && t.direction === 'CREDIT'); const card = txs.filter(t => ['CARD','POS','MERCHANT'].includes(t.type) && t.direction === 'CREDIT'); if (cash.length < 5) return []; const ct = cash.reduce((s,t) => s + t.amount, 0); const cdt = card.reduce((s,t) => s + t.amount, 0); if (cdt > 0 && ct/cdt > 4) return [{ ruleId: 'CIB-001', category: 'CASH_BUSINESS', severity: 'MEDIUM', score: 25, message: `Cash deposits ${(ct/cdt).toFixed(1)}x card revenue — unusual cash intensity`, transactions: cash.slice(0, 5).map(t => t.id) }]; const byDay = {}; for (const t of cash) { const d = t.date.toISOString().slice(0, 10); byDay[d] = (byDay[d] || 0) + t.amount; } const da = Object.values(byDay); if (da.length >= 10) { const avg = da.reduce((s,a) => s+a, 0) / da.length; const sd = Math.sqrt(da.reduce((s,a) => s + (a-avg)**2, 0) / da.length); if (sd/avg < 0.1 && avg > 1000) return [{ ruleId: 'CIB-001', category: 'CASH_BUSINESS', severity: 'HIGH', score: 30, message: `Suspiciously consistent daily deposits (avg $${avg.toFixed(0)}, CV=${(sd/avg).toFixed(3)})`, transactions: cash.slice(0, 5).map(t => t.id) }]; } return []; } },
      // CRY-004: Privacy coins
      { id: 'CRY-004', category: 'CRYPTO', detect: (txs) => { const p = txs.filter(t => /\b(monero|xmr|zcash|zec|dash|grin|beam|pirate chain)\b/i.test(t.counterparty) || /\b(monero|xmr|zcash|zec|dash|grin|beam|pirate chain)\b/i.test(t.description)); return p.length ? [{ ruleId: 'CRY-004', category: 'CRYPTO', severity: 'HIGH', score: 35, message: `${p.length} privacy coin transaction(s)`, transactions: p.map(t => t.id) }] : []; } },
      // CRY-005: Peel chain
      { id: 'CRY-005', category: 'CRYPTO', detect: (txs) => { const out = txs.filter(t => t.direction === 'DEBIT' && t.cryptoAddress).sort((a,b) => a.date - b.date); if (out.length < 4) return []; const ua = new Set(out.map(t => t.cryptoAddress)); if (ua.size < out.length * 0.8) return []; let dec = 0; for (let i = 1; i < out.length; i++) if (out[i].amount < out[i-1].amount) dec++; return dec / (out.length-1) > 0.7 ? [{ ruleId: 'CRY-005', category: 'CRYPTO', severity: 'HIGH', score: 35, message: `Peel chain: ${out.length} outbound to ${ua.size} unique addresses with decreasing amounts`, transactions: out.slice(0, 10).map(t => t.id) }] : []; } },
      // CRY-006: DeFi/NFT
      { id: 'CRY-006', category: 'CRYPTO', detect: (txs) => { const d = txs.filter(t => /\b(uniswap|sushiswap|pancakeswap|aave|compound|curve|1inch|dex|swap|bridge|opensea|nft|mint)\b/i.test(t.counterparty) || /\b(uniswap|sushiswap|pancakeswap|aave|compound|curve|1inch|dex|swap|bridge|opensea|nft|mint)\b/i.test(t.description)); if (d.length < 3) return []; const s = d.sort((a,b) => a.date - b.date); for (let i = 0; i < s.length-1; i++) { const gap = Math.abs(s[i+1].date - s[i].date) / 60000; if (gap < 5 && s[i].direction !== s[i+1].direction && Math.abs(s[i].amount) > 50000) return [{ ruleId: 'CRY-006', category: 'CRYPTO', severity: 'HIGH', score: 30, message: `DeFi flash loan pattern: $${Math.abs(s[i].amount).toFixed(0)} in/out within ${gap.toFixed(0)}min`, transactions: [s[i].id, s[i+1].id] }]; } const tot = d.reduce((x,t) => x + Math.abs(t.amount), 0); return tot > 50000 ? [{ ruleId: 'CRY-006', category: 'CRYPTO', severity: 'MEDIUM', score: 20, message: `${d.length} DeFi/NFT transactions totaling $${tot.toFixed(0)}`, transactions: d.slice(0, 5).map(t => t.id) }] : []; } },
      // SAN-001: Sanctions evasion corridor
      { id: 'SAN-001', category: 'SANCTIONS_EVASION', detect: (txs) => { const inter = new Set(['AE','TR','GE','AM','KZ','KG','UZ','TJ','CN','HK','SG','MY']); const sanc = new Set(['RU','IR','KP','SY','CU','BY','VE']); const it = txs.filter(t => inter.has(t.counterpartyCountry)); const st = txs.filter(t => sanc.has(t.counterpartyCountry)); if (it.length && st.length) return [{ ruleId: 'SAN-001', category: 'SANCTIONS_EVASION', severity: 'CRITICAL', score: 50, message: `Transactions with sanctioned (${[...new Set(st.map(t => t.counterpartyCountry))].join(',')}) and intermediary (${[...new Set(it.map(t => t.counterpartyCountry))].join(',')}) countries`, transactions: [...st, ...it].slice(0, 10).map(t => t.id) }]; if (it.length >= 3) { const tot = it.reduce((s,t) => s + Math.abs(t.amount), 0); if (tot > 100000) return [{ ruleId: 'SAN-001', category: 'SANCTIONS_EVASION', severity: 'HIGH', score: 35, message: `High-volume ($${tot.toFixed(0)}) to sanctions evasion corridors`, transactions: it.slice(0, 5).map(t => t.id) }]; } return []; } },
      // PEP-001: Government kickback pattern
      { id: 'PEP-001', category: 'CORRUPTION', detect: (txs) => { const gov = txs.filter(t => /\b(government|ministry|municipal|federal|procurement|tender|contract|grant)\b/i.test(t.counterparty) || /\b(government|ministry|municipal|federal|procurement|tender|contract|grant)\b/i.test(t.description)); if (!gov.length) return []; const gi = gov.filter(t => t.direction === 'CREDIT' && t.amount > 25000).sort((a,b) => a.date - b.date); for (const g of gi) { const sus = txs.filter(t => t.direction === 'DEBIT' && t.date > g.date && (t.date - g.date) / 86400000 < 14 && /\b(consult|advis|fee|commission|service)\b/i.test(t.description) && t.amount > g.amount * 0.05); if (sus.length) return [{ ruleId: 'PEP-001', category: 'CORRUPTION', severity: 'HIGH', score: 35, message: `Gov payment ($${g.amount.toFixed(0)}) followed by fee payments in 14 days — possible kickback`, transactions: [g.id, ...sus.map(t => t.id)] }]; } return []; } },
      // NET-001: High-risk network connections
      { id: 'NET-001', category: 'NETWORK', detect: (txs) => { const cpRisk = {}; for (const t of txs) { if (!t.counterparty) continue; if (!cpRisk[t.counterparty]) cpRisk[t.counterparty] = { vol: 0, cnt: 0, rf: new Set() }; cpRisk[t.counterparty].vol += Math.abs(t.amount); cpRisk[t.counterparty].cnt++; if (this.highRiskCountries.has(t.counterpartyCountry)) cpRisk[t.counterparty].rf.add('HRC'); if (this.taxHavens.has(t.counterpartyCountry)) cpRisk[t.counterparty].rf.add('TH'); if (/\b(holdings|trading|consulting|services|international|global|ventures)\b/i.test(t.counterparty)) cpRisk[t.counterparty].rf.add('SHELL'); } const hr = Object.entries(cpRisk).filter(([_,v]) => v.rf.size >= 2); return hr.length >= 3 ? [{ ruleId: 'NET-001', category: 'NETWORK', severity: 'HIGH', score: 35, message: `${hr.length} counterparties with multiple risk flags — high-risk network cluster`, transactions: txs.filter(t => hr.some(([cp]) => cp === t.counterparty)).slice(0, 10).map(t => t.id), details: { counterparties: hr.map(([cp, v]) => ({ name: cp, flags: [...v.rf] })) } }] : []; } },
      // NET-002: Circular transaction cycle detection
      { id: 'NET-002', category: 'NETWORK', detect: (txs) => { const alerts = []; const outb = txs.filter(t => t.direction === 'DEBIT' && t.counterparty).sort((a,b) => a.date - b.date); const inb = txs.filter(t => t.direction === 'CREDIT' && t.counterparty).sort((a,b) => a.date - b.date); const flows = []; for (const i of inb) { for (const o of outb) { const g = (o.date - i.date) / 3600000; if (g > 0 && g <= 72 && o.amount >= i.amount * 0.8 && o.amount <= i.amount * 1.05) { flows.push({ from: i.counterparty, to: o.counterparty, iid: i.id, oid: o.id }); break; } } } const seen = new Set(); for (const f1 of flows) { for (const f2 of flows) { if (f1.from === f2.to && f1.to === f2.from && f1.from !== f1.to) { const k = [f1.from, f1.to].sort().join('|'); if (!seen.has(k)) { seen.add(k); alerts.push({ ruleId: 'NET-002', category: 'NETWORK', severity: 'CRITICAL', score: 45, message: `Circular fund flow: ${f1.from} ↔ ${f1.to}`, transactions: [f1.iid, f1.oid, f2.iid, f2.oid].filter(Boolean) }); } } } } if (!alerts.length && flows.length >= 3) { const adj = {}; for (const f of flows) (adj[f.from] = adj[f.from] || []).push(f); for (const a of Object.keys(adj)) { for (const f1 of adj[a] || []) { for (const f2 of adj[f1.to] || []) { if (f2.to === a && f1.to !== a) return [{ ruleId: 'NET-002', category: 'NETWORK', severity: 'CRITICAL', score: 50, message: `3-node cycle: ${a} → ${f1.to} → ${f2.to} → back`, transactions: [f1.iid, f1.oid, f2.iid, f2.oid].filter(Boolean) }]; } } } } return alerts; } },
      // NET-003: Funnel account detection
      { id: 'NET-003', category: 'NETWORK', detect: (txs) => { const alerts = []; const senders = new Set(txs.filter(t => t.direction === 'CREDIT' && t.counterparty).map(t => t.counterparty)); const receivers = new Set(txs.filter(t => t.direction === 'DEBIT' && t.counterparty).map(t => t.counterparty)); const ct = txs.filter(t => t.direction === 'CREDIT').reduce((s,t) => s + t.amount, 0); if (senders.size >= 5 && receivers.size <= 2 && ct > 50000) alerts.push({ ruleId: 'NET-003', category: 'NETWORK', severity: 'HIGH', score: 35, message: `Funnel: ${senders.size} sources → ${receivers.size} destinations ($${ct.toFixed(0)})`, transactions: txs.filter(t => t.direction === 'CREDIT').slice(0, 10).map(t => t.id) }); if (receivers.size >= 5 && senders.size <= 2) { const dt = txs.filter(t => t.direction === 'DEBIT').reduce((s,t) => s + t.amount, 0); if (dt > 50000) alerts.push({ ruleId: 'NET-003', category: 'NETWORK', severity: 'HIGH', score: 30, message: `Distribution: ${senders.size} source(s) → ${receivers.size} recipients ($${dt.toFixed(0)})`, transactions: txs.filter(t => t.direction === 'DEBIT').slice(0, 10).map(t => t.id) }); } return alerts; } },
      // FRD-001: Duplicate payments
      { id: 'FRD-001', category: 'FRAUD', detect: (txs) => { const alerts = []; const deb = txs.filter(t => t.direction === 'DEBIT' && t.counterparty && t.amount > 1000); const seen = {}; for (const t of deb) { const k = `${t.counterparty}|${t.amount.toFixed(2)}`; (seen[k] = seen[k] || []).push(t); } for (const [_,g] of Object.entries(seen)) { if (g.length >= 2) { const s = g.sort((a,b) => a.date - b.date); for (let i = 1; i < s.length; i++) { const gap = (s[i].date - s[i-1].date) / 86400000; if (gap <= 30 && gap > 0) { alerts.push({ ruleId: 'FRD-001', category: 'FRAUD', severity: 'HIGH', score: 30, message: `Duplicate payment to "${s[0].counterparty}" for $${s[0].amount.toFixed(2)} within ${Math.ceil(gap)} days`, transactions: [s[i-1].id, s[i].id] }); break; } } } } return alerts; } },
      // FRD-002: Payroll fraud / ghost employees
      { id: 'FRD-002', category: 'FRAUD', detect: (txs) => { const p = /\b(payroll|salary|wages|compensation|bonus|commission|stipend)\b/i; const pt = txs.filter(t => t.direction === 'DEBIT' && (p.test(t.description) || p.test(t.counterparty))); if (pt.length < 3) return []; const ag = {}; for (const t of pt) { const k = t.amount.toFixed(2); if (!ag[k]) ag[k] = new Set(); ag[k].add(t.counterparty || t.id); } for (const [amt, recs] of Object.entries(ag)) { if (recs.size >= 5 && parseFloat(amt) > 500) return [{ ruleId: 'FRD-002', category: 'FRAUD', severity: 'HIGH', score: 30, message: `${recs.size} identical payroll payments of $${amt} — potential ghost employees`, transactions: pt.filter(t => t.amount.toFixed(2) === amt).slice(0, 10).map(t => t.id) }]; } return []; } },
      // FRD-003: Procurement fraud / kickback
      { id: 'FRD-003', category: 'FRAUD', detect: (txs) => { const deb = txs.filter(t => t.direction === 'DEBIT' && t.amount > 5000).sort((a,b) => a.date - b.date); for (const d of deb) { const kb = txs.find(t => t.direction === 'CREDIT' && t.date > d.date && (t.date - d.date) / 86400000 < 45 && t.amount >= d.amount * 0.05 && t.amount <= d.amount * 0.3 && t.counterparty && t.counterparty !== d.counterparty); if (kb) return [{ ruleId: 'FRD-003', category: 'FRAUD', severity: 'HIGH', score: 35, message: `$${d.amount.toFixed(0)} payment then $${kb.amount.toFixed(0)} (${(kb.amount/d.amount*100).toFixed(0)}%) receipt — possible kickback`, transactions: [d.id, kb.id] }]; } return []; } },
      // FRD-004: Asset misappropriation
      { id: 'FRD-004', category: 'FRAUD', detect: (txs) => { const p = /\b(personal|savings|self|own|private|family|spouse)\b/i; const s = txs.filter(t => t.direction === 'DEBIT' && t.amount > 10000 && (p.test(t.counterparty) || p.test(t.description))); if (!s.length) return []; const tot = s.reduce((x,t) => x + t.amount, 0); return [{ ruleId: 'FRD-004', category: 'FRAUD', severity: 'CRITICAL', score: 40, message: `${s.length} transfers to personal/family accounts ($${tot.toFixed(0)}) — possible misappropriation`, transactions: s.slice(0, 5).map(t => t.id) }]; } },
      // FRD-005: Insurance claims fraud
      { id: 'FRD-005', category: 'FRAUD', detect: (txs) => { const p = /\b(insurance|claim|settlement|indemnity|premium|loss)\b/i; const it = txs.filter(t => p.test(t.counterparty) || p.test(t.description)); if (it.length < 2) return []; const cl = it.filter(t => t.direction === 'CREDIT' && t.amount > 5000); if (cl.length < 3) return []; const s = cl.sort((a,b) => a.date - b.date); const span = (s[s.length-1].date - s[0].date) / 86400000; if (span > 180) return []; const tot = cl.reduce((x,t) => x + t.amount, 0); return [{ ruleId: 'FRD-005', category: 'FRAUD', severity: 'HIGH', score: 30, message: `${cl.length} insurance claims ($${tot.toFixed(0)}) within ${Math.ceil(span)} days — excessive frequency`, transactions: cl.map(t => t.id) }]; } },
      // FRD-006: Financial statement fraud / revenue recognition
      { id: 'FRD-006', category: 'FRAUD', detect: (txs) => { const cr = txs.filter(t => t.direction === 'CREDIT' && t.amount > 25000); const pe = cr.filter(t => { const m = t.date.getMonth(), d = t.date.getDate(); return [2,5,8,11].includes(m) && d >= 26; }); if (pe.length < 2) return []; const rev = pe.filter(p => txs.some(t => t.direction === 'DEBIT' && t.amount >= p.amount * 0.8 && t.amount <= p.amount * 1.05 && t.date > p.date && (t.date - p.date) / 86400000 <= 15)); if (rev.length) return [{ ruleId: 'FRD-006', category: 'FRAUD', severity: 'CRITICAL', score: 45, message: `${rev.length} period-end credits reversed within 15 days — possible revenue fraud`, transactions: rev.map(t => t.id) }]; return [{ ruleId: 'FRD-006', category: 'FRAUD', severity: 'MEDIUM', score: 20, message: `${pe.length} large credits at quarter-end — review for revenue manipulation`, transactions: pe.slice(0, 5).map(t => t.id) }]; } }
    ];
  }
}

const service = new TransactionMonitoringService();

export default async function handler(req, res) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });
  try {
    const { transactions, entityProfile, options } = req.body;
    if (!transactions || !Array.isArray(transactions)) return res.status(400).json({ error: 'transactions array is required' });
    const result = await service.analyzeTransactions({ transactions, entityProfile, options });
    res.json(result);
  } catch (error) {
    console.error('Transaction monitoring error:', error);
    res.status(500).json({ error: error.message });
  }
}
